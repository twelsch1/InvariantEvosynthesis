package verification;

import benchmark.Benchmark;
import com.microsoft.z3.*;

import java.util.ArrayList;


/**
 * The Verifier class provides a verify function for the invariant synthesis problem that also factors in the temporary and permanent
 * restrictions generated by Restrictive Branchwise Predicate Synthesis.
 * @author Thomas Welsch
 *
 */

public class Verifier {
	

	private String preConAssertionString;
	
	private String transitionAssertionString;
	
	private String postConAssertionString;
	
	/**
	 * Temporary variable names used during synthesis.
	 */
	private String[] synthesisVariableNames;
	/**
	 * Variable names as they appear in the formal specification.
	 */
	private String[] functionVariableNames;
	
	private String[] functionVariableTypes;
	
	private String[] globalVariableNames;
	
	private String[] globalVariableTypes;
	
	private String[] primeFunctionVariableNames;
	
	/**
	 * Predicates that were obtained as restrictions during RBPS.
	 */
	private String[] localRestrictions;
	
	
	private String[] positiveMappings;

	/**
	 * Additional functions defined in the formal specification.
	 */
	private String[] definedFunctions;

	private String functionName;
	/**
	 * Clauses found during RBPS.
	 */
	private String[] clauses;


	/**
	 * The target function's declaration.
	 */
	private String functionDeclarationString;

	/**
	 * The SMT Lib logic e.g. LIA obtained from the formal specification.
	 */
	private String logic; 
	
	public Verifier(Benchmark benchmark) {
		
		this.logic = benchmark.getLogic();
		this.functionName = benchmark.getFunctionName();
		this.functionDeclarationString = benchmark.getFunString();
		this.synthesisVariableNames = benchmark.getSynthesisVariableNames();
		this.functionVariableNames = benchmark.getFunctionVariables();
		this.functionVariableTypes = benchmark.getFunctionVariableTypes();
		this.globalVariableNames = benchmark.getGlobalVariables();
		this.globalVariableTypes = benchmark.getGlobalVariableTypes();
		this.definedFunctions = benchmark.getDefinedFunctions();
		this.postConAssertionString = benchmark.getPostConAssertionString();
		this.preConAssertionString = benchmark.getPreConAssertionString();
		this.transitionAssertionString = benchmark.getTransAssertionString();
		
		
		/*this.primeFunctionVariableNames = new String[this.functionVariableNames.length];
		for (int i = 0; i < this.functionVariableNames.length; i++) {
			this.primeFunctionVariableNames[i] = this.functionVariableNames[i] + "!";
		}*/
		
		this.primeFunctionVariableNames = benchmark.getPrimedFunctionVariables();
		
	}
	
	private TestExample getImplicationCounterexampleFromModel(Model model, Context ctx, String[] globalVariableNames, String[] functionVariableNames, String[] primeFunctionVariableNames) throws VerificationException {
		long[] inputs = new long[functionVariableNames.length];
		long[] primeInputs = new long[functionVariableNames.length];
		long[] globalVariables = new long[globalVariableNames.length];
		//get the inputs from the model
		
		
		for (int i = 0; i < functionVariableNames.length; i++) {
			Expr<?> expr = ctx.mkIntConst(functionVariableNames[i]);
			inputs[i] = Long.parseLong(model.eval(expr, true).toString());
		}
		
		for (int i = 0; i < primeFunctionVariableNames.length; i++) {
			Expr<?> expr = ctx.mkIntConst(primeFunctionVariableNames[i]);
			primeInputs[i] = Long.parseLong(model.eval(expr, true).toString());
		}

		for (int i = 0; i < globalVariableNames.length; i++) {
			Expr<?> expr = ctx.mkIntConst(globalVariableNames[i]);
			globalVariables[i] = Long.parseLong(model.eval(expr, true).toString());
			//System.out.println(globalVariables[i]);
		}
		

		
		return new TestExample(inputs, primeInputs, globalVariables);
	}
	
	//Output is known based off which call failed.
	private TestExample getPosNegCounterexampleFromModel(Model model, Context ctx, String[] globalVariableNames, int output, String[] functionVariableNames) throws VerificationException {
		long[] inputs = new long[functionVariableNames.length];
		long[] globalVariables = new long[globalVariableNames.length];
		//get the inputs from the model
		for (int i = 0; i < functionVariableNames.length; i++) {
			Expr<?> expr = ctx.mkIntConst(functionVariableNames[i]);
			inputs[i] = Long.parseLong(model.eval(expr, true).toString());
		}

		for (int i = 0; i < globalVariableNames.length; i++) {
			Expr<?> expr = ctx.mkIntConst(globalVariableNames[i]);
			globalVariables[i] = Long.parseLong(model.eval(expr, true).toString());
			//System.out.println(globalVariables[i]);
		}
		
		
		return new TestExample(inputs, output, globalVariables);
	}
	

	/**
	 * Verifies if a program is correct for the input space determined by the Verifier class's state.
	 * If it is, status on the VerificationResult is set as UNSAT. If it is incorrect and a counterexample can be found, the
	 * status is set as SAT and a CounterExample on which that program is incorrect is also set. If an Exception is encountered
	 * or it is unknown if it is correct, status is set as UNKNOWN.
	 * @return VerificationResult - Contains Z3 status and, if encountered, an exception.
	 */
	public VerificationResult verify(String program) {
		//Initializes default vcp, then initializes a context via try with resources, ensuring that the context
		//is closed after try block.
		VerificationCallParameters vcp = new VerificationCallParameters();
		try (Context ctx = new Context()) {
		//Verification call is performed and VerificationResult is returned.
		return verify(program,ctx,vcp.getTimeout(),vcp.getThreads(), vcp.getCounterExamples());
		}
	}
	
	/**
	 * Verifies if a program is correct for the input space determined by the Verifier class's state.
	 * If it is, status on the VerificationResult is set as UNSAT. If it is incorrect and a counterexample can be found, the
	 * status is set as SAT and a CounterExample on which that program is incorrect is also set. If an Exception is encountered
	 * or it is unknown if it is correct, status is set as UNKNOWN.
	 * @param program The program to be verified.
	 * @param vcp A class that has optional parameters including number of threads, timeout, previously found
	 * CounterExamples and a Z3 context.
	 * @return VerificationResult - Contains Z3 status and, if encountered, an exception.
	 */
	public VerificationResult verify(String program, VerificationCallParameters vcp) {
		//If provided VerificationCallParameters does not have a context, initialize one with try with resources 
		//which ensures it closed after the try.
		if (vcp.getContext() == null) {
			try (Context ctx = new Context()) {
				//Verification call is performed and VerificationResult is returned.
				return verify(program, ctx, vcp.getTimeout(), vcp.getThreads(), vcp.getCounterExamples());
			}
		}
		//Verification call is performed using provided context and VerificationResult is returned.
		return verify(program, vcp.getContext(), vcp.getTimeout(), vcp.getThreads(), vcp.getCounterExamples());
	}
	
	private static String produceVarsString(String[] variables) {
		String retVal = "";
		for (int i = 0; i < variables.length-1; i++) {
			retVal += variables[i] + " ";
		}
		
		retVal += variables[(variables.length-1)];
		
		return retVal;
	}
	
	public ArrayList<TestExample> generateInitialExamples(int numEachExample) {
		ArrayList<TestExample> retVal = new ArrayList<>();
		
		//ArrayList<CounterExample> posExamples = new ArrayList<>();
		boolean positive = true;
		for (int i = 0; i < numEachExample; i++) {
			TestExample ce = generateInitialExample(positive, retVal);
			
			if (ce == null) {
				//System.out.println("Breaking");
				break;
			}
			
			retVal.add(ce);
		}
		

		positive = false;
		
		for (int i = 0; i < numEachExample; i++) {
			TestExample ce = generateInitialExample(positive, retVal);
			
			if (ce == null) {
				//System.out.println("Breaking");
				break;
			}
			
			retVal.add(ce);
		}
		
		
		return retVal;
		
		
	}
	
	private TestExample generateInitialExample(boolean positive, ArrayList<TestExample> ces) {

		// initialize solver and params from the context


		// if the synthType is program, run verifyProgram. If the model is null, return
		// with UNSAT status indicating correctness.
		// If SAT, get the CounterExample and return.
		TestExample ce = null;
		try (Context ctx = new Context()) {
			
			Solver solver = ctx.mkSolver();
			Params params = ctx.mkParams();


			params.add("timeout", 1000);
			
			//String aString = "(" + functionName + " " + produceVarsString(this.functionVariableNames) + ")";
			
			//
			Model model = null;
			String verificationString;
			if (positive) {
				verificationString = generatePreamble("false", true, ces) + generateCounterExampleBounds(this.globalVariableNames) +
						"(assert (not " + this.preConAssertionString
						+ "))";
			} else {
				verificationString = generatePreamble("true", true, ces)  + generateCounterExampleBounds(this.globalVariableNames) + 
						"(assert (not " + this.postConAssertionString
						+ "))";
			}
			
			//System.out.println(verificationString);

			//System.out.println(verificationString);
			Status status = solver.check(ctx.parseSMTLIB2String(verificationString, null, null, null, null));
			// System.out.println("Good 1");

			if (status == Status.SATISFIABLE) {
				model = solver.getModel();
				ce = this.getPosNegCounterexampleFromModel(model, ctx, this.globalVariableNames, positive ? 1: 0, this.functionVariableNames);
			} else if (status == Status.UNKNOWN) {
				//System.out.println("We are here");
				throw new Exception("Unknown Status");
			}



		} catch (Exception e) {
			//For now just prints stack trace and we return as null below to break.
			//We actually need to account for numberFormatException. But we'll worry about that later.
			//I think that is going to need to be done by directly saying it has to come in the integer range.
			e.printStackTrace();
		}
		
		return ce;

	}
	
	public boolean verifyIsInductiveLemma(String program) {




		// if the synthType is program, run verifyProgram. If the model is null, return
		// with UNSAT status indicating correctness.
		// If SAT, get the CounterExample and return.

		try(Context ctx = new Context()) 
		{
			
			Solver solver = ctx.mkSolver();
			Params params = ctx.mkParams();
			
			
			params.add("timeout", 500);
			solver.setParameters(params);
			
			String verificationString = generatePreamble(program, false) + "(assert (not (and " + this.preConAssertionString
					+ "\n";
			
			verificationString += this.transitionAssertionString
					+ ")))\n";
			// System.out.println("PreCon verification: " + verificationString);

		//	 System.out.println("Ver String: " + verificationString);

			Status status = solver.check(ctx.parseSMTLIB2String(verificationString, null, null, null, null));

			// System.out.println("Good 1");

			if (status == Status.UNSATISFIABLE) {
				return true;
			} 

		} catch (Exception e) {
			e.printStackTrace();
		}

		return false;
	}
	
	

	/**
	 * A private function that marshals parameters from a VerificationCallParameters instance and performs
	 * the actual verification process.
	 * @param program The program to be verified.
	 * @param ctx The Z3 Context instance used by the Z3 SMT.
	 * @param timeout The time in milliseconds to allow the verification call. If -1, time is unlimited.
	 * @param threads The number of threads allocated to Z3.
	 * @param counterExamples Previously found CounterExample instances, should only be included if the program
	 * is known to be incorrect. Forces verification call to find a new CounterExample.
	 * @return VerificationResult - Contains status and, if encountered, an exception.
	 */
	private VerificationResult verify(String program, Context ctx, int timeout, int threads,
			ArrayList<TestExample> counterExamples) {

		// initialize solver and params from the context
		Solver solver = ctx.mkSolver();
		Params params = ctx.mkParams();

		// if the optional parameters are included and valid, set them
		if (threads > 1) {
			params.add("threads", threads);
		}
		if (timeout > 0) {
			params.add("timeout", timeout);
		}
		solver.setParameters(params);

		// if the synthType is program, run verifyProgram. If the model is null, return
		// with UNSAT status indicating correctness.
		// If SAT, get the CounterExample and return.

		try {
			ArrayList<TestExample> ces = new ArrayList<>();
			Model model = null;
			String verificationString = generatePreamble(program, true) + "(assert (not " + this.preConAssertionString
					+ "))";
			// System.out.println("PreCon verification: " + verificationString);

			// System.out.println("Ver String: " + verificationString);

			Status status = solver.check(ctx.parseSMTLIB2String(verificationString, null, null, null, null));

			// System.out.println("Good 1");

			if (status == Status.SATISFIABLE) {
				model = solver.getModel();
				ces.add(this.getPosNegCounterexampleFromModel(model, ctx, this.globalVariableNames, 1, this.functionVariableNames));
			} else if (status == Status.UNKNOWN) {
				throw new Exception("Unknown Status");
			}




			if (ces.isEmpty()) {
				verificationString = generatePreamble(program, true) + "(assert (not " + this.postConAssertionString
						+ "))";

				// System.out.println("PostCon verification: " + verificationString);
				status = solver.check(ctx.parseSMTLIB2String(verificationString, null, null, null, null));

				// System.out.println("Good 2");
				if (status == Status.SATISFIABLE) {
					model = solver.getModel();
					ces.add(this.getPosNegCounterexampleFromModel(model, ctx, this.globalVariableNames, 0, this.functionVariableNames));
				} else if (status == Status.UNKNOWN) {
					throw new Exception("Unknown Status");
				}
			}
			
			if (ces.isEmpty()) {
				
				verificationString = generatePreamble(program, false) + "(assert (not " + this.transitionAssertionString
						+ "))";
				status = solver.check(ctx.parseSMTLIB2String(verificationString, null, null, null, null));

				if (status == Status.SATISFIABLE) {
					model = solver.getModel();
					ces.add(this.getImplicationCounterexampleFromModel(model, ctx, this.globalVariableNames, this.functionVariableNames,
							this.primeFunctionVariableNames));
				} else if (status == Status.UNKNOWN) {
					throw new Exception("Unknown Status");
				}
			}

			if (ces.isEmpty()) {
				return new VerificationResult(Status.UNSATISFIABLE, null);
			} else {
				return new VerificationResult(Status.SATISFIABLE, ces);
			}

		} catch (Exception e) {
			return new VerificationResult(e, Status.UNKNOWN);
		}

	}
	
	public boolean isProgramCorrect(String program, String[] extraAssertions) {
		//System.out.println("Let ")
		this.setLocalRestrictions(extraAssertions);
		return (this.verify(program)).getStatus() == Status.UNSATISFIABLE;
	}
	
	public boolean isProgramCorrect(String program) {
		return (this.verify(program)).getStatus() == Status.UNSATISFIABLE;
	}
	
	

	/**
	  Runs a full verification check to see if program is an invariant for the specification. Intentionally makes sure no RBPS
	  restrictions are included. Run at the end of the process as a sanity check for the solution.
	 * @return Returns true if program is an invariant, false otherwise.
	 */
	public boolean verifySanity(String program) {
		
		//initialize solver and params from the context
		try(Context ctx = new Context()) {
		Solver solver = ctx.mkSolver();
		Params params = ctx.mkParams();
		solver.setParameters(params);

		//ensures no
		this.localRestrictions = null;
		this.positiveMappings = null;
		this.clauses = null;


			String verificationString = generatePreamble(program, false) + "(assert (not "
					+ "(and " + this.preConAssertionString + "\n " + this.transitionAssertionString + "\n"
					+ this.postConAssertionString +"\n)))";
			
			
			//System.out.println("Ver String: " + verificationString);
			
			Status status = solver.check(ctx.parseSMTLIB2String(verificationString, null, null, null, null));
			
			return status == Status.UNSATISFIABLE;


				
				
				

			
		} catch (Exception e) {
			throw e;
		}
		
		
		
	}
	
	private String generatePreamble(String program, boolean includeRestrictions, ArrayList<TestExample> ces) {
		String retVal = "(set-logic " + this.logic + ")\n";
		retVal += generateFunctionVariableDeclarationsString(this.globalVariableNames, this.globalVariableTypes);

		retVal += generateDefinedFunctionsString(this.definedFunctions);
		if (!program.isBlank()) {
			retVal += this.functionDeclarationString.replace("funToken;", program) + "\n";
		}
	//	System.out.println("Howdy");
		if (includeRestrictions) {
			retVal += generateLocalRestrictionsString(this.localRestrictions, this.functionDeclarationString,this.functionName, 
				this.functionVariableNames, this.functionVariableTypes, this.synthesisVariableNames);
		} else {
			//retVal += generateFunctionVariableDeclarationsString(this.primeFunctionVariableNames, this.globalVariableTypes);
			retVal += generateLocalRestrictionsString(this.positiveMappings, this.functionDeclarationString,this.functionName, 
					this.functionVariableNames, this.functionVariableTypes, this.synthesisVariableNames);
		}
		
		retVal += generateClausesString(this.clauses, this.functionDeclarationString,this.functionName, 
				this.functionVariableNames, this.synthesisVariableNames);
		
		retVal += generateCounterExamplesRestrictionsString(this.functionVariableNames, ces);
		
		for (int i = 0; i < functionVariableNames.length; i++) {
			retVal = retVal.replace(synthesisVariableNames[i], functionVariableNames[i]);
		}
		
		//System.out.println(retVal);
		
		return retVal;
	}
	
	private String generatePreamble(String program, boolean includeRestrictions) {
		return generatePreamble(program, includeRestrictions, null);
	}
	
	
	private static String generateFunctionVariableDeclarationsString(String[] variableNames, String[] variableTypes) {
		String retVal = "";
		//Declare variables
		for (int i = 0; i < variableNames.length; i++) {
			retVal += "(declare-fun " + variableNames[i] + " () " + variableTypes[i]+ ")\n";
		}
		
		return retVal;
	}
	
	private static String generateDefinedFunctionsString(String[] definedFunctions) {
		String retVal = "";
		for (int i = 0; i < definedFunctions.length; i++) {
			retVal += definedFunctions[i] + "\n";
		}
		return retVal;
	}
	
	private static String generateLocalRestrictionsString(String[] localRestrictions, String functionDeclarationString, String functionName,
			String[] functionVariableNames, String[] functionVariableTypes, String[] synthesisVariableNames) {
		String defPattern = "define-fun " + functionName;
		String retVal = "";
		if (localRestrictions != null) {
			for (int i = 0; i < localRestrictions.length; i++) {
				retVal += "(define-fun " + functionName + "_restriction_" + i + " (";
				
				for (int j = 0; j < functionVariableNames.length; j++) {
					retVal += "(" + functionVariableNames[j] + " " + functionVariableTypes[j] + ")";
				}
				
				retVal += ") Bool " + localRestrictions[i] + ")\n";
				
				retVal += "(assert (" + functionName + "_restriction_" + i + " ";
				for (int j = 0; j < functionVariableNames.length; j++) {
					retVal += functionVariableNames[j] + " ";
				}
				retVal += "))\n";

			}
		}

		
		return retVal;
		
	}
	
	private static String generateCounterExamplesRestrictionsString(String[] functionVariableNames,
			ArrayList<TestExample> ces) {
		// String defPattern = "define-fun " + functionName;
		String retVal = "";
		if (ces != null && !ces.isEmpty()) {
			retVal += "(assert (not (or false ";
			for (TestExample ce : ces) {
				long[] inputs = ce.getInputs();
				retVal += "(and true ";
				for (int i = 0; i < inputs.length; i++) {
					retVal += "(= " + functionVariableNames[i] + " " + inputs[i] + ") ";
				}
				retVal += ")";

			}
			retVal += ")))\n";
			
		}

		return retVal;

	}
	
	//this prevents a counterexample from being generated where the variable in the input model is outside the Java
	//int range.
	private static String generateCounterExampleBounds(String[] functionVariableNames) {
		// String defPattern = "define-fun " + functionName;
		String retVal = "(assert (and true ";
		
		for (int i = 0; i < functionVariableNames.length; i++) {
			retVal += "(>= " + functionVariableNames[i] + " " + Long.MIN_VALUE + ") " +
			"(<= " + functionVariableNames[i] + " " + Long.MAX_VALUE + ") ";
		}
		
		retVal += "))\n";
		

		return retVal;

	}
	private static String generateClausesString(String[] clauses, String functionDeclarationString, String functionName,
			String[] functionVariableNames, String[] synthesisVariableNames) {
		String defPattern = "define-fun " + functionName;
		String retVal = "";
		if (clauses != null) {
			for (int i = 0; i < clauses.length; i++) {
				retVal += functionDeclarationString.replace(defPattern, defPattern + "_clause_" + i)
						.replace("funToken;", clauses[i]) + "\n";
				String preamble = "(assert (not (" + functionName + "_clause_" + i + " ";
				retVal += preamble;
				for (int j = 0; j < functionVariableNames.length; j++) {
					retVal += functionVariableNames[j] + " ";
				}
				retVal += ")))\n";

			}
		}

		
		return retVal;
		
	}
	
	public int acquireSizeOfFunctionVariablesList() {
		return this.functionVariableNames.length;
	}

	public String[] getDefinedFunctions() {
		return definedFunctions;
	}

	public void setDefinedFunctions(String[] definedFunctions) {
		this.definedFunctions = definedFunctions;
	}


	public String[] getLocalRestrictions() {
		return localRestrictions;
	}


	public String[] getSynthesisVariableNames() {
		return synthesisVariableNames;
	}

	public void setSynthesisVariableNames(String[] synthesisVariableNames) {
		this.synthesisVariableNames = synthesisVariableNames;
	}


	public String getFunctionDeclarationString() {
		return functionDeclarationString;
	}

	public void setLocalRestrictions(String[] localRestrictions) {
		this.localRestrictions = localRestrictions;
	}

	public String[] getClauses() {
		return clauses;
	}

	public void setClauses(String[] clauses) {
		this.clauses = clauses;
	}

	public void setPositiveMappings(String[] positiveMappings) {
		this.positiveMappings = positiveMappings;
	}
	
	public static void main(String[] args) throws Exception {
		String benchmarkFile = "src/main/resources/EasyInvariantBenchmarks/fib_10.sl";
		//String benchmarkFile = "src/main/resources/benchmarks/fg_max4.sl";
		Benchmark benchmark = Benchmark.parseBenchmark(benchmarkFile);
		
		Verifier ver = new Verifier(benchmark);
		
		System.out.println("Gathering examples");
		ArrayList<TestExample> ces = ver.generateInitialExamples(50);
		System.out.println("Gathered " + ces.size());
		
		
		for (TestExample ce: ces) {
			System.out.println(ce.toString());
		}
		
	}
	
	
}


